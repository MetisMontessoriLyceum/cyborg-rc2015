#include "NXCDefs.h"
#include "HTSMUX-driver.h"

int sen1 = false;
int sen2 = false;
int sen3 = false;
int sen4 = false;
int sen5 = false;
int rotaOLD = 0;
int rotaNEW = 0;
int tickOLD = 0;
int tickNEW = 0;

void init () {

  SetSensor(S4, SENSOR_LOWSPEED);

  // Tell the SMUX to start scanning its ports.
  // this takes 500ms
  if (!HTSMUXscanPorts(S4)) {
    // Scan failed, handle the error
    TextOut(0, LCD_LINE1, "Scan failed!");
    Wait(1000);
  }


  SetSensorType(IN_1, SENSOR_TYPE_LIGHT_ACTIVE);
  SetSensorType(IN_2, SENSOR_TYPE_LOWSPEED);
  SetSensorType(IN_3, SENSOR_TYPE_LOWSPEED);
  if (!smuxSetSensorLegoLight(msensor_S4_1, true)) {
    TextOut(0, LCD_LINE1, "smux sens 1 failed!");
    Wait(1000);
  }
  if (!smuxSetSensorLegoLight(msensor_S4_2, true)) {
    TextOut(0, LCD_LINE1, "smux sens 2 failed!");
    Wait(1000);
  }
  if (!smuxSetSensorLegoLight(msensor_S4_3, true)) {
    TextOut(0, LCD_LINE1, "smux sens 3 failed!");
    Wait(1000);
  }
  if (!smuxSetSensorLegoLight(msensor_S4_4, true)) {
    TextOut(0, LCD_LINE1, "smux sens 4 failed!");
    Wait(1000);
  }
}

int sens (int num) {
  int ret;
  switch (num) {
    case -1:
      ret = SensorUS(IN_3);
      break;
    case 0:
      ret = SensorUS(IN_2);
      break;
    case 1:
      ret = smuxSensorLegoLightNorm(msensor_S4_1);
      break;
    case 2:
      ret = smuxSensorLegoLightNorm(msensor_S4_2);
      break;
    case 3:
      ret = Sensor(IN_1);
      break;
    case 4:
      ret = smuxSensorLegoLightNorm(msensor_S4_4);
      break;
    case 5:
      ret = smuxSensorLegoLightNorm(msensor_S4_3);
      break;
    default:
      TextOut(0, LCD_LINE1, "Error line 54: num can only be 1 to 5");
      Wait(1000);
  }
  return ret;
}

void updateActive () {
  if (sens(1) < 35) {
    sen1 = true;
  }
  else {
    sen1 = false;
  }

  if (sens(2) < 50) {
    sen2 = true;
  }
  else {
    sen2 = false;
  }
  if (sens(3) < 700) {
    sen3 = true;
  }
  else {
    sen3 = false;
  }

  if (sens(4) < 50) {
    sen4 = true;
  }
  else {
    sen4 = false;
  }

  if (sens(5) < 35) {
    sen5 = true;
  }
  else {
    sen5 = false;
  }
}




void Move (int motorL, int motorR) {
  if (motorL == motorR && motorL != 0) {
    OnFwdReg(OUT_AC,motorL,OUT_REGMODE_IDLE);
  }
  else {
    if (motorL == 0) {
      Off(OUT_A);
    }
    else if (motorL >= 0) {
      OnFwdReg(OUT_A,motorL,OUT_REGMODE_IDLE);
    }
    else {
      OnRevReg(OUT_A,0-motorL,OUT_REGMODE_IDLE);
    }

    if (motorR == 0) {
      Off(OUT_C);
    }
    else if (motorR >= 0) {
      OnFwdReg(OUT_C,motorR,OUT_REGMODE_IDLE);
    }
    else {
      OnRevReg(OUT_C,0-motorR,OUT_REGMODE_IDLE);
    }
  }

}

void WaitForLine (string d) {
  long OldTime = CurrentTick();
  while (true) {
    if (sens(3) < 600)  {
      break;
    }
    else if (CurrentTick() > OldTime + 1000) {
      switch (d) {
        case "left":
          Move(75,-75);
          Wait(2000);
          break;
        case "right":
          Move(-75,75);
          Wait(2000);
          break;
      }
      break;
    }
  }
}

task main () {
  init();

  /*rotaOLD = MotorRotationCount(OUT_C);
  Move(-75,75);
  until(MotorRotationCount(OUT_C) - rotaOLD > 1200);
  Move(0,0);*/
  Move(75,-75);
  until(false);
  //while (!ButtonPressed(BTNCENTER,true)) {
  //  //ClearScreen();
  //  NumOut(0, LCD_LINE2, MotorRotationCount(OUT_A));
  //}
  //Move(0,0);
  //rotaNEW = MotorRotationCount(OUT_A);
  //NumOut(0, LCD_LINE1, rotaNEW - rotaOLD);
  //until(false);


}
